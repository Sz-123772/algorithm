## 基础算法

### 高精度计算

#### 定义

```c++
const int N = 1e5 + 5; // 数字最大长度
bool sign = true; // 记录数据的正负
struct bign { // 定义大整数类型
    int num[N], len;
    bign() { memset(num, 0, sizeof(num)); len = 0; }
};

void read(bign &a) { // 读入大整数
    string s;
    cin >> s;
    for(int i = s.size() - 1; i >= 0; -- i)
        a.num[a.len ++] = s[i] - '0';
}

void print(bign &a) { // 输出大整数
    int i = a.len - 1;
    while(i > 0 && a.num[i] == 0) -- i; // 去除前导零
    if(!sign) cout << "-";
    for(i; i >= 0; -- i) cout << a.num[i];
    cout << endl;
}
```

#### **高精 + 高精**

```c++
// a + b = c
void add(bign a, bign b, bign &c){
    int carry = 0;
    for(int i = 0; i < a.len || i < b.len; ++ i) {
        int temp = a.num[i] + b.num[i] + carry;
        c.num[c.len ++] = temp % 10;
        carry = temp / 10;
    }
    if(carry) c.num[c.len ++] = carry;
}
```

#### **高精 - 高精**

```c++
// 比较a和b
void compare(bign a, bign b) {
    if(a.len > b.len) sign = true;
    else if(a.len < b.len) sign = false;
    else {
        for(int i = a.len; i >= 0; -- i) {
            if(a.num[i] == b.num[i]) continue;
            else {
                if(a.num[i] > b.num[i]) sign = true;
                else sign = false;
                return ;
            }
        }
        sign = true;
    }
}
// a - b = c
void sub(bign a, bign b, bign &c) {
    compare(a, b);
    if(sign) {
        for(int i = 0; i < a.len; ++ i) {
            if(a.num[i] < b.num[i]) {
                -- a.num[i + 1];
                a.num[i] += 10;
            }
            c.num[c.len ++] = a.num[i] - b.num[i];
        }
    } else {
        for(int i = 0; i < b.len; ++ i) {
            if(b.num[i] < a.num[i]) {
                -- b.num[i + 1];
                b.num[i] += 10;
            }
            c.num[c.len ++] = b.num[i] - a.num[i];
        }
    }
}
```

#### **高精 $\times$ 低精**

```c++
// a * b = c
void mul(bign a, int b, bign &c){
    int carry = 0;
    for(int i = 0; i < a.len; ++ i) {
        int temp = a.num[i] * b + carry;
        c.num[c.len ++] = temp % 10;
        carry = temp / 10;
    }
    while(carry) {
        c.num[c.len ++] = carry % 10;
        carry /= 10;
    }
}
```

#### **高精 $\times$ 高精**

|            |      4      |      3      |      2      |      1      |      0      |
| :--------: | :---------: | :---------: | :---------: | :---------: | :---------: |
|    $a$     |             |             |    $a_2$    |    $a_1$    |    $a_0$    |
|    $b$     |             |             |    $b_2$    |    $b_1$    |    $b_0$    |
|            |             |             |             |             |             |
| $a * b[0]$ |             |             | $a_2 * b_0$ | $a_1 * b_0$ | $a_0 * b_0$ |
| $a * b[1]$ |             | $a_2 * b_1$ | $a_1 * b_1$ | $a_0 * b_1$ |             |
| $a * b[2]$ | $a_2 * b_2$ | $a_1 * b_2$ | $a_0 * b_2$ |             |             |


```c++
// a * b = c
void mull(bign a, bign b, bign &c) {
    for(int i = 0; i < a.len; ++ i)
        for(int j = 0; j < b.len; ++ j)
            c.num[i + j] += a.num[i] * b.num[j]; // i, j相乘的贡献在i + j位上
    c.len = a.len + b.len + 1; // 乘积的位数不超过两数的数位之和
    for(int i = 0; i < c.len; ++ i) {
        c.num[i + 1] += c.num[i] / 10; // 处理进位
        c.num[i] %= 10;
    }
}
```

#### **高精 / 低精**

```c++
// a / b = c ... r
void div(bign a, int b, bign &c, int &r){
    c.len = a.len;
    r = 0;
    for(int i = a.len - 1; i >= 0; -- i) {
        r = r * 10 + a.num[i];
        if(r < b) c.num[i] = 0;
        else {
            c.num[i] = r / b;
            r %= b;
        }
    }
}
```

### 排序算法

#### **第一类基于比较的排序算法** $O(n^2)$

##### **选择排序**

每轮从**未排序区间**选择**最小**的元素，将其放到**已排序区间**的**末尾**。

设数组的长度为 $n$ ，选择排序的算法流程如下。

1. 初始状态下，所有元素未排序，即未排序（索引）区间为 $[1, n]$ 。

2. 选取区间 $[1, n]$ 中的最小元素，将其与索引 $1$ 处的元素交换。完成后，数组前 1 个元素已排序。

3. 选取区间 $[2, n]$ 中的最小元素，将其与索引 $2$ 处的元素交换。完成后，数组前 2 个元素已排序。

4. 以此类推。经过 $n - 1$ 轮选择与交换后，数组前 $n - 1$ 个元素已排序。

5. 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成

```c++
for(int i = 1; i <= n - 1; ++ i) { // 轮数
    int k = i;
    for(int j = i + 1; i <= n; ++ j) // i ~ n 的最小值
        if(nums[j] > nums[k])
            k = j;
    swap(nums[k], nums[i]);
}
```

##### **插入排序**

将未排序区间的第一个元素与其左侧已排序区间的元素逐一比较大小，将该元素插入到正确的位置。

设数组的长度为 $n$ ，插入排序的算法流程如下。

1. 初始状态下，数组的第 1 个元素已完成排序。
2. 选取数组的第 2 个元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。
3. 选取第 3 个元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。
4. 以此类推，在最后一轮（第`n`轮）中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。

```c++
for(int i = 2; i <= n; ++ i) { // 已排序的元素个数
    int j = i - 1, base = nums[i];
    while(j >= 1 && nums[j] > base) {
        nums[j + 1] = nums[j]; // 将nums[j]向右移一位
        -- j;
    }
    num[j + 1] = base; // 将base插入到j+1的位置
}
```

##### **冒泡排序**

从数组最左端开始向右遍历，依次**比较相邻元素**大小，如果**“左元素 > 右元素”**就交换二者。遍历完成后，**最大**的元素会被移动到数组的**最右端**。

设数组的长度为 $n$ ，冒泡排序的算法流程如下。

1. 首先，对 $n$ 个元素执行“冒泡”，**将数组的最大元素交换至正确位置**。
2. 接下来，对剩余 $n - 1$ 个元素执行“冒泡”，**将第二大元素交换至正确位置**。
3. 以此类推，经过 $n - 1$ 轮“冒泡”后，**前 $n - 1$ 大的元素都被交换至正确位置**。
4. 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。

```c++
for(int i = 1; i <= n - 1; ++ i) // 轮数
    for(int j = 1; j <= n - i; ++ j) // 对 n - i + 1 个元素执行冒泡
        if(nums[j] <= nums[j + 1])
            swap(nums[j], nums[j + 1]);
```

#### **第二类基于比较的排序算法** $O(nlogn)$

##### **堆排序**

##### **归并排序**

##### **快速排序**



#### 基于分类的排序算法

##### **计数排序**

##### **基数排序**

##### **桶排序**

## 基础算法

### 高精度计算

#### 定义

```c++
const int N = 1e5 + 5; // 数字最大长度
bool sign = true; // 记录数据的正负
struct bign { // 定义大整数类型
    int num[N], len;
    bign() { memset(num, 0, sizeof(num)); len = 0; }
};

void read(bign &a) { // 读入大整数
    string s;
    cin >> s;
    for(int i = s.size() - 1; i >= 0; -- i)
        a.num[a.len ++] = s[i] - '0';
}

void print(bign &a) { // 输出大整数
    int i = a.len - 1;
    while(i > 0 && a.num[i] == 0) -- i; // 去除前导零
    if(!sign) cout << "-";
    for(i; i >= 0; -- i) cout << a.num[i];
    cout << endl;
}
```

#### **高精 + 高精**

```c++
// a + b = c
void add(bign a, bign b, bign &c){
    int carry = 0;
    for(int i = 0; i < a.len || i < b.len; ++ i) {
        int temp = a.num[i] + b.num[i] + carry;
        c.num[c.len ++] = temp % 10;
        carry = temp / 10;
    }
    if(carry) c.num[c.len ++] = carry;
}
```

#### **高精 - 高精**

```c++
// 比较a和b
void compare(bign a, bign b) {
    if(a.len > b.len) sign = true;
    else if(a.len < b.len) sign = false;
    else {
        for(int i = a.len; i >= 0; -- i) {
            if(a.num[i] == b.num[i]) continue;
            else {
                if(a.num[i] > b.num[i]) sign = true;
                else sign = false;
                return ;
            }
        }
        sign = true;
    }
}
// a - b = c
void sub(bign a, bign b, bign &c) {
    compare(a, b);
    if(sign) {
        for(int i = 0; i < a.len; ++ i) {
            if(a.num[i] < b.num[i]) {
                -- a.num[i + 1];
                a.num[i] += 10;
            }
            c.num[c.len ++] = a.num[i] - b.num[i];
        }
    } else {
        for(int i = 0; i < b.len; ++ i) {
            if(b.num[i] < a.num[i]) {
                -- b.num[i + 1];
                b.num[i] += 10;
            }
            c.num[c.len ++] = b.num[i] - a.num[i];
        }
    }
}
```

#### **高精 $\times$ 低精**

```c++
// a * b = c
void mul(bign a, int b, bign &c){
    int carry = 0;
    for(int i = 0; i < a.len; ++ i) {
        int temp = a.num[i] * b + carry;
        c.num[c.len ++] = temp % 10;
        carry = temp / 10;
    }
    while(carry) {
        c.num[c.len ++] = carry % 10;
        carry /= 10;
    }
}
```

#### **高精 $\times$ 高精**

|            |      4      |      3      |      2      |      1      |      0      |
| :--------: | :---------: | :---------: | :---------: | :---------: | :---------: |
|    $a$     |             |             |    $a_2$    |    $a_1$    |    $a_0$    |
|    $b$     |             |             |    $b_2$    |    $b_1$    |    $b_0$    |
|            |             |             |             |             |             |
| $a * b[0]$ |             |             | $a_2 * b_0$ | $a_1 * b_0$ | $a_0 * b_0$ |
| $a * b[1]$ |             | $a_2 * b_1$ | $a_1 * b_1$ | $a_0 * b_1$ |             |
| $a * b[2]$ | $a_2 * b_2$ | $a_1 * b_2$ | $a_0 * b_2$ |             |             |


```c++
// a * b = c
void mull(bign a, bign b, bign &c) {
    for(int i = 0; i < a.len; ++ i)
        for(int j = 0; j < b.len; ++ j)
            c.num[i + j] += a.num[i] * b.num[j]; // i, j相乘的贡献在i + j位上
    c.len = a.len + b.len + 1; // 乘积的位数不超过两数的数位之和
    for(int i = 0; i < c.len; ++ i) {
        c.num[i + 1] += c.num[i] / 10; // 处理进位
        c.num[i] %= 10;
    }
}
```

#### **高精 / 低精**

```c++
// a / b = c ... r
void div(bign a, int b, bign &c, int &r){
    c.len = a.len;
    r = 0;
    for(int i = a.len - 1; i >= 0; -- i) {
        r = r * 10 + a.num[i];
        if(r < b) c.num[i] = 0;
        else {
            c.num[i] = r / b;
            r %= b;
        }
    }
}
```

### 排序算法

#### **第一类基于比较的排序算法** $O(n^2)$

##### **选择排序**

每轮从**未排序区间**选择**最小**的元素，将其放到**已排序区间**的**末尾**。

设数组的长度为 $n$ ，选择排序的算法流程如下。

1. 初始状态下，所有元素未排序，即未排序（索引）区间为 $[1, n]$ 。

2. 选取区间 $[1, n]$ 中的最小元素，将其与索引 $1$ 处的元素交换。完成后，数组前 1 个元素已排序。

3. 选取区间 $[2, n]$ 中的最小元素，将其与索引 $2$ 处的元素交换。完成后，数组前 2 个元素已排序。

4. 以此类推。经过 $n - 1$ 轮选择与交换后，数组前 $n - 1$ 个元素已排序。

5. 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成

```c++
for(int i = 1; i <= n - 1; ++ i) { // 轮数
    int k = i;
    for(int j = i + 1; i <= n; ++ j) // i ~ n 的最小值
        if(nums[j] > nums[k])
            k = j;
    swap(nums[k], nums[i]);
}
```

##### **插入排序**

将未排序区间的第一个元素与其左侧已排序区间的元素逐一比较大小，将该元素插入到正确的位置。

设数组的长度为 $n$ ，插入排序的算法流程如下。

1. 初始状态下，数组的第 1 个元素已完成排序。
2. 选取数组的第 2 个元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。
3. 选取第 3 个元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。
4. 以此类推，在最后一轮（第`n`轮）中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。

```c++
for(int i = 2; i <= n; ++ i) { // 已排序的元素个数
    int j = i - 1, base = nums[i];
    while(j >= 1 && nums[j] > base) {
        nums[j + 1] = nums[j]; // 将nums[j]向右移一位
        -- j;
    }
    num[j + 1] = base; // 将base插入到j+1的位置
}
```

##### **冒泡排序**

从数组最左端开始向右遍历，依次**比较相邻元素**大小，如果**“左元素 > 右元素”**就交换二者。遍历完成后，**最大**的元素会被移动到数组的**最右端**。

设数组的长度为 $n$ ，冒泡排序的算法流程如下。

1. 首先，对 $n$ 个元素执行“冒泡”，**将数组的最大元素交换至正确位置**。
2. 接下来，对剩余 $n - 1$ 个元素执行“冒泡”，**将第二大元素交换至正确位置**。
3. 以此类推，经过 $n - 1$ 轮“冒泡”后，**前 $n - 1$ 大的元素都被交换至正确位置**。
4. 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。

```c++
for(int i = 1; i <= n - 1; ++ i) // 轮数
    for(int j = 1; j <= n - i; ++ j) // 对 n - i + 1 个元素执行冒泡
        if(nums[j] <= nums[j + 1])
            swap(nums[j], nums[j + 1]);
```

#### **第二类基于比较的排序算法** $O(nlogn)$

##### **堆排序**

堆排序是一种基于堆数据结构实现的高效排序算法。

**堆排序**的流程如下：

1. 输入数组并建立**大顶堆**。完成后，最大元素位于堆顶。
2. 将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 $1$ ，已排序元素数量加 $1$ 。
3. 从堆顶元素开始，从顶到底执行堆化操作（$down$）。完成堆化后，堆的性质得到修复。
4. 循环执行第 `2` 步和第 `3` 步。循环 $n - 1$ 轮后，即可完成数组排序。

![1258817-20190420150936225-1441021270](D:\Accer\Desktop\algorithm\algorithm\pic\sort_algorithm\heapsort\1258817-20190420150936225-1441021270.gif)

```c++
const int N = 1e5 + 5;
int heap[N], idx;
// 向下调整
void down(int u) {
    while(u + u <= idx) {
        int v = u + u;
        if(v + 1 <= idx && heap[v] < heap[v + 1]) ++ v;
        if(heap[v] < heap[u]) break;
        swap(heap[v], heap[u]);
        u = v;
    }
}
int main() {
    int n; cin >> n;
    for(int i = 1; i <= n; ++ i) {
        int x; cin >> x;
        heap[++ idx] = x;
    }
    for(int i = idx / 2; i; -- i) down(i); // 调整为大根堆
    // 堆排序
    for(int i = 1; i <= n; ++ i) {
        swap(heap[1], heap[idx]);
        -- idx;
        down(1);
    }
    for(int i = 1; i <= n; ++ i) cout << heap[i] << " ";
    return 0;
}
```

##### **归并排序**

归并排序包含“划分”和“合并”阶段。

1. **划分阶段**：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。
2. **合并阶段**：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

**归并排序**的流程如下：

“划分阶段”从顶至底递归地将数组从中点切分为两个子数组。

1. 计算数组中点 `mid` ，递归划分左子数组（区间 `[left, mid]` ）和右子数组（区间 `[mid + 1, right]` ）。
2. 递归执行步骤 `1.` ，直至子数组区间长度为 1 时终止。

“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。

![merge_sort_overview](D:\Accer\Desktop\algorithm\algorithm\pic\sort_algorithm\msort\merge_sort_overview.png)

```c++
void merge_sort(int l, int r) {
    if(l >= r) return ;
    // 划分阶段
    int mid = (l + r) / 2;
    merge_sort(l, mid); 
    merge_sort(mid + 1, r);
    // 合并阶段
    int k = 0, i = l, j = mid + 1;
    while(i <= mid && j <= r) {
        if(nums[i] <= nums[j]) temp[k ++] = nums[i ++];
        else temp[k ++] = nums[j ++];
    }
    while(i <= mid) { 
        temp[k ++] = nums[i ++];
    }
    while(j <= r) {
        temp[k ++] = nums[j ++];
    }
    for(i = l, j = 0; i <= r; ++ i, ++ j)
        nums[i] = temp[j];
}
```



##### **快速排序**

快速排序的核心操作是**“哨兵划分”**，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧**($左侧\le base \le 右侧$)**。**哨兵划分**的流程如下。

1. 选取数组的中间元素作为基准数，初始化两个指针 `i` 和 `j` 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 `i`（`j`）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 `2.` ，直到 `i` 和 `j` 相遇时停止。

**快速排序**的流程如下。

1. 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。
2. 然后，对左子数组和右子数组分别递归执行“哨兵划分”。
3. 持续递归，直至子**数组长度为 1 时终止**，从而完成整个数组的排序。

![quick_sort_overview](D:\Accer\Desktop\algorithm\algorithm\pic\sort_algorithm\qsort\quick_sort_overview.png)

```c++
void quick_sort(int l, int r) {
    if(l >= r) return ; // 终止
    
    // 哨兵划分
    int mid = (l + r) >> 1;
    int i = l - 1, j = r + 1, base = nums[mid];
    while(i < j) {
        do ++ i; while(nums[i] < base);
        do -- j; while(nums[j] > base);
        if(i < j) swap(nums[i], nums[j]);
    }
    
    // 持续递归
    quick_sort(l, j);
    quick_sort(j + 1, r);
}
```

#### 基于分类的排序算法

##### **计数排序**

##### **基数排序**

##### **桶排序**
